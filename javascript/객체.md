# 객체
## 객체 생성과 프로퍼티 접근
```js
const food1 = {
  name: '햄버거',
  price: 5000,
  vegan: false
};

console.log(
  food1.name, // 마침표 프로퍼티 접근 연산자
  food1['price'] // 대괄호 프로퍼티 접근 연산자
);
```
## 프로퍼티 삭제
```js
const person1 = {
  name: '홍길동',
  age: 24,
  school: '한국대',
  major: '컴퓨터공학'
};

delete person1.age;
delete person1['major'];
```
* `delete` 로 삭제
* 삭제하려는 프로퍼티가 없어도 오류 X
## 키의 동적 사용
```js
const product1 = {
  name: '노트북',
  color: 'gray',
  price: 800000
}

function addModifyProperty (obj, key, value) {
  // obj.key = value; // ⚠️ 의도와 다른 작업 수행
  obj[key] = value;
}
function deleteProperty (obj, key) {
  // delete obj.key // ⚠️ 의도와 다른 작업 수행
  delete obj[key];
}
```
* 변수를 객체의 키로 사용할 경우 대괄호 접근법을 사용해야함
## ES6 추가 문법
### 단축 표현
```js
const x = 1, y = 2;

const obj1 = { 
  x: x,
  y: y
}

const obj2 = { x, y }
```
### 메서드 정의
```js
const person = {
  name: '홍길동',
  
  salutate (formal) {
    return formal
    ? `안녕하십니까, ${this.name}입니다.`
    : `안녕하세요, ${this.name}이에요.`;
  }
}
console.log(person.salutate(true));
```
## 생성자
```js
// 생성자 함수 
function YalcoChicken (name, no) {
  this.name = name;
  this.no = no;
  this.introduce = function () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
}

// 인스턴스 생성
const chain1 = new YalcoChicken('판교', 3);
const chain2 = new YalcoChicken('강남', 17);
const chain3 = new YalcoChicken('제주', 24);
```
* 재사용할 수 있는 객체를 만드는 것이 목적인 함수
* 생성자 함수명은 일반적으로 대문자로 시작
* 암묵적으로 `this` 객체를 생성하고 반환
* `this.~` 로 생성될 프로퍼티 정의
* 생성자 함수는 new 와 함께 사용
* 생성자 함수를 사용해 생성된 객체들은 **힙 메모리**에 저장
* 일반 함수로 생성된 객체와 생성자 함수로 생성된 객체의 차이는 프로토타입의 `constructor`의 체인이 다름

### 프로토타입
```js
function YalcoChicken (name, no) {
  this.name = name;
  this.no = no;
  this.introduce = function () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
}

const chain1 = new YalcoChicken('판교', 3);
console.log(chain1);

// 루트에 새로운 매서드 추가하여 모든 인스턴스에 매서드 추가
YalcoChicken.prototype.introEng = function () {
  return `Welcome to Yalco Chicken at ${this.name}!`;
};

console.log(chain1.introEng());
```
### 생성자 함수의 정적 프로퍼티/메서드
* 생성자 함수의 고유 정적 프로퍼티/메서드는 생성자 함수에서만 접근 가능
```js
function YalcoChicken (name, no) {
  this.name = name;
  this.no = no;
  this.introduce = function () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
}

// 생성자 고유의 프로퍼티
YalcoChicken.brand = '얄코치킨';
YalcoChicken.contact = function () {
  return `${this.brand}입니다. 무엇을 도와드릴까요?`;
};

const chain1 = new YalcoChicken('판교', 3);

console.log(YalcoChicken.contact());  // Success
console.log(chain1.contact());        // Fail
```
## 클래스
* 클래스는 함수 객체
```js
class YalcoChicken {
  constructor (name, no) {
    this.name = name;
    this.no = no;
  }
  introduce () {  // 메서드
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
}
```
### `constructor` 메서드
* 인스턴스 생성시 인자를 받아 프로퍼티 초기화
* 클래스에 오직 하나
* 기본값 사용 가능
* 필요없을 경우 생략 가능
* 반환 금지
```js
class Person {
  constructor (name, age, married = false) {
    this.name = name;
    this.age = age;
    this.married = married;
  }
}

const person1 = new Person('박영희', 30, true);
const person2 = new Person('오동수', 18);
console.log(person1, person2);
```
### 클래스의 메서드
* 생성자 함수의 메서드와 달리 프로토타입에 메세드가 들어감
```js
// 클래스 메서드
class Dog {
  bark () {
    return '멍멍';
  }
}
const badugi = new Dog();
console.log(badugi, badugi.bark());
```
```js
// 생성자 함수 메서드
function Dog2 () {
  this.bark = function () {
    return '멍멍';
  }
}
const badugi = new Dog2();
console.log(badugi, badugi.bark());
```
### 필드
* `constructor` 밖에서, `this` 없이 인스턴스의 프로퍼티 정의
```js
// 필드값이 지정되어 있으므로 constructor 메서드 필요없음
class Slime {
  hp = 50;
  op = 4;
  attack (enemy) {
    enemy.hp -= this.op;
    this.hp += this.op/4;
  }
}
```
* 인자로 받아온 값이 있을 경우 `constructor`로 값 지정
```js
class YalcoChicken {
  no = 0;
  menu = { '후라이드': 10000, '양념치킨': 12000 };

  constructor (name, no) {
    this.name = name;
    if (no) this.no = no;
  }
  introduce () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
  order (name) {
    return `${this.menu[name]}원입니다.`
  }
}
```
### 정적 필드와 메서드
* 인스턴스 없이 클래스 차원에서 호출
* 메모리 한 곳만 차지
* 정적 메서드에서는 정적 필드만 사용 가능
```js
class YalcoChicken {

  // 정적 변수와 메서드
  static brand = '얄코치킨';
  static contact () {
    return `${this.brand}입니다. 무엇을 도와드릴까요?`;
  }

  constructor (name, no) {
    this.name = name;
    this.no = no;
  }
  introduce () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
}

console.log(YalcoChicken);
console.log(YalcoChicken.contact());
```
## 접근자
* getter, setter 함수
* 내부 프로퍼티의 값을 읽거나 설정
* `get`, `set을` 앞에 붙임
* 함수 모양이지만 프로퍼티처럼 사용
### getter
* 특정 프로퍼티를 원하는 방식으로 가공하여 출력할 때 사용
### setter
* 하나의 인자를 받음
* 특정 프로퍼티에 값이 저장되는 방식을 조작하거나 제한하는데 사용
```js
const person1 = {
  age: 17,

  get koreanAge () {
    return this.age + 1;
  },

  set koreanAge (krAge) {
    this.age = krAge - 1;
  }
}

console.log(person1, person1.koreanAge);  // get
person1.koreanAge = 20;  // set
```
* 클래스 사용 예시
```js
class YalcoChicken {
  constructor (name, no) {
    this.name = name;
    this.no = no;
  }
  get chainTitle() {
    return `${this.no}호 ${this.name}점`;
  }
  set chainNo(chainNo) {
    if (typeof chainNo !== 'number') return;
    if (chainNo <= 0) return;
    this.no = chainNo;
  }
}

const chain1 = new YalcoChicken('판교', 3);
console.log(chain1.chainTitle);
chain1.chainNo = '4';
```
## 은닉
### 캡슐화
* 객체지향의 주요 요소 중 하나 - 객체 내부의 값을 감추는 것
* 인스턴스 프로퍼티 값을 함부로 조회하거나 수정하지 못하게함
* 자바스크립트의 필드는 기본적으로 public
* 은닉화된 프로퍼티는 constructor, 접근자, 기타 함수로만 접근 가능하며 인스턴스에서 바로 접근 불가
* 필드명 앞에 `#` 을 붙임
* 필드와 `constructor` 둘다 정의해야됨
```js
class Employee {
  #name = '';
  #age = 0;
  constructor (name, age) {
    this.#name = name;
    this.#age = age;
  }
  get name () {
    return this.#name[0] + '모씨';
  }
  get age () {
    return this.#age - (this.#age % 10) + '대';
  }
  set age (age) {
    if (typeof age === 'number' && age > 0) {
      this.#age = age;
    };
  }
  getOlder(years) { this.#age += years; }
}

const emp1 = new Employee('김복동', 22);
```
## 상속
* 클래스에서는 extends 로 상속관계 정의
* 자식 클래스는 부모의 클래스 속성을 가져옴
* 자식 클래스의 인스턴스는 부모 클래스의 인스턴스로 인식됨
```js
class Bird {
  wings = 2;
}
class Eagle extends Bird {
  claws = 2;
}
class Penguin extends Bird {
  swim () { console.log('수영중...'); }
}
class EmperorPenguin extends Penguin {
  size = 'XXXL';
}
```
### 오버라이딩
* 자식 클래스에서 부모로부터 물려받은 속성이나 기능을 재정의
```js
class Bird {
  wings = 2;
  canFly = true;
  travel () { console.log('비행중...') }
}
class Eagle extends Bird {
  claws = 2;
}
class Penguin extends Bird {
  canFly = false;   // 부모의 canFly 재정의
  travel () { console.log('수영중...') }  // 부모의 travel 재정의
}
```
### super
* 부모 클래스의 constructor 또는 메서드 호출
* 자식 클래스의 constructor 내에서는 부모 클래스의 constructor를 가리킴
* 자식 클래스의 메서드 내에서는 부모 클래스를 가리킴
```js
class YalcoChicken {
  no = 0;
  menu = { '후라이드': 10000, '양념치킨': 12000 };

  constructor (name, no) {
    this.name = name;
    if (no) this.no = no;
  }
  introduce () {
    return `안녕하세요, ${this.no}호 ${this.name}점입니다!`;
  }
  order (name) {
    return `${this.menu[name]}원입니다.`
  }
}

class ConceptYalcoChicken extends YalcoChicken {
  #word = '';
  constructor (name, no, word) {
    super(name, no);
    this.#word = word;
  }
  introWithConcept () {
    return super.introduce() + ' ' + this.#word;
  }
  order (name) {
    return super.order(name) + ' ' + this.#word;
  }
}

const pikaChain = new ConceptYalcoChicken('도봉', 50, '피카피카~');
```
## 스프레드
* 값을 복사하거나 새로운 값을 포함하는 새로운 객체 생성에 사용
```js
const class1 = {
  x: 1, y: 'A', z: true
};

const class2 = { ...class1 };
```
* 객체 내부의 참조타입의 프로퍼타입이 참조타입일 경우 원본 객체 값을 오염시킬 수 있음
```js
const class1 = {
  x: 1,
  y: { a: 2 },
  z: [3, 4]
};

const class2 = { ...class1 };
class1.x++;
class1.y.a++;   // 오염
class1.z[0]++;  // 오염
```
## 디스트럭쳐링
* 객체의 값을 간단하게 가져오는 방법
```js
const obj1 = {
  x: 1, y: 2, z: 3
};

const {x, y, z} = obj1;
```